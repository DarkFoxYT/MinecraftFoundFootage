#version 410 core
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_storage_buffer_object : enable

#line 0 1
layout(std140) uniform CameraMatrices {
    mat4 ProjMat;
    mat4 IProjMat;
    mat4 ViewMat;
    mat4 IViewMat;
    mat3 IViewRotMat;
    vec3 CameraPosition;
    float NearPlane;
    float FarPlane;
} VeilCamera;

#line 4 0

struct BirdData {
    vec3 position;
    vec3 rotation;
};


layout (std430, binding = 0) buffer BirdBuffer {
    BirdData birds[];
} birdBuffer;

layout (std430, binding = 1) buffer IndirectBuffer {
    uint count;
    uint primCount;
    uint firstIndex;
    uint baseVertex;
    uint baseInstance;
} indirectBuffer;

uniform vec3[6] FlockCenters;
uniform int FlockAmount;
uniform int NumOfInstances;
uniform float FrustumPlanes[24];

const double MAX_DISTANCE = 2.0;

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

float rand(vec2 co){
    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
}

vec3 getFixedDirection(vec3 direction, vec3 currentRotation) {
    if (abs(dot(normalize(currentRotation), normalize(direction))) < 0.2) {
        return direction + normalize(vec3(rand(vec2(direction.x, direction.y)), rand(vec2(direction.y, direction.z)), rand(vec2(direction.z, direction.x)))) * .1;
    }

    return direction;
}


void main() {
    uint idx = gl_GlobalInvocationID.x;
    uint idy = gl_GlobalInvocationID.y;
    int increment = 0;


    vec3 cameraPos = VeilCamera.CameraPosition;
    vec3 player = vec3(cameraPos.x,0 ,cameraPos.z);




    memoryBarrierShared();
    barrier();

    /// RUNS ONCE ///
    uint compactIndex = atomicAdd(indirectBuffer.primCount, 1);

    vec3 oldRotation = birdBuffer.birds[compactIndex].rotation;
    vec3 newRotation = birdBuffer.birds[compactIndex].rotation;
    vec3 position = birdBuffer.birds[compactIndex].position;

    if (!(distance(FlockCenters[compactIndex % FlockAmount], position) > 60)) {
        vec3 totalPosition = vec3(0.0);
        vec3 totalPositionDiffernece = vec3(0.0);
        vec3 totalRotation = vec3(0.0);

        int otherCount = 0;

        double smallestDistance = 2.0;
        for (int i = 0; i < NumOfInstances; i++) {
            if (i == int(compactIndex)) continue;

            bool isCloseEnough = abs(dot(birdBuffer.birds[i].position - position, birdBuffer.birds[i].position - position)) < 4.0;
            if (!isCloseEnough) continue;


            bool insideView = dot(normalize(birdBuffer.birds[i].position - position), newRotation) > -.6;
            //if (!insideView) continue;

            BirdData other = birdBuffer.birds[i];

            float distance = length(other.position - position);

            if (!isnan(other.position.x) && !isnan(other.position.y) && !isnan(other.position.z) && distance > 0.1) {
                if (distance < smallestDistance) {
                    smallestDistance = distance;
                }

                totalPositionDiffernece += getFixedDirection(vec3(normalize(other.position - position) * abs(smallestDistance - 2)), newRotation);
                totalPosition += other.position;
                totalRotation += getFixedDirection(vec3(newRotation * abs(smallestDistance - 2)), newRotation);

                otherCount ++;
            }
        }

        if (otherCount > 0) {
            newRotation += normalize((totalPosition / float(otherCount)) - position);

            newRotation -= getFixedDirection(vec3(normalize(totalPositionDiffernece / float(otherCount)) * abs(smallestDistance - 2) * 0.7), newRotation);
            newRotation += getFixedDirection(vec3(normalize(totalRotation / float(otherCount)) * abs(smallestDistance - 2)), newRotation);
        }

        newRotation += normalize(FlockCenters[compactIndex % FlockAmount] - position) * (distance(FlockCenters[compactIndex % FlockAmount], position) * .01);

        newRotation = mix(normalize(newRotation), oldRotation, 0.6);

        position += normalize(newRotation) * .01;
    } else {
        position = FlockCenters[compactIndex % FlockAmount] + vec3(rand(vec2(position.x, position.y)), rand(vec2(position.y, position.z)), rand(vec2(position.z, position.x))) * 4.0;
    }


    birdBuffer.birds[compactIndex].position = position;
    birdBuffer.birds[compactIndex].rotation = normalize(newRotation);


    barrier();
    memoryBarrierShared();
}